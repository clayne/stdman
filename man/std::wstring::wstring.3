.TH std::basic_string::basic_string 3 "2022.07.31" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::basic_string::basic_string \- std::basic_string::basic_string

.SH Synopsis
basic_string();                      (until
explicit basic_string( const         C++17)
Allocator& alloc );
basic_string()
noexcept(noexcept(
Allocator() )) :                     (since
                                     C++17)
basic_string( Allocator() )          (until
{}                                   C++20)

explicit basic_string( const
Allocator& alloc ) noexcept;
constexpr basic_string()
noexcept(noexcept(
Allocator() )) :

basic_string( Allocator() )          (since
{}                                   C++20)

explicit constexpr
basic_string( const
Allocator& alloc ) noexcept;
basic_string( size_type
count, CharT ch,                            (until
const Allocator& alloc =                    C++20)
Allocator() );
constexpr basic_string(
size_type count, CharT ch,                  (since
const Allocator& alloc =                    C++20)
Allocator() );
basic_string( const
basic_string& other,
                                                   (until
size_type pos,                                     C++20)

const Allocator& alloc =
Allocator() );
constexpr basic_string(
const basic_string& other,
                                                   (since
size_type pos,                                     C++20)

const Allocator& alloc =
Allocator() );
basic_string( const
basic_string& other,

size_type pos, size_type                                  (until
count,                                                    C++20)

const Allocator& alloc =
Allocator() );
constexpr basic_string(
const basic_string& other,

size_type pos, size_type                                  (since
count,                                                    C++20)

const Allocator& alloc =
Allocator() );
basic_string( const CharT*
s, size_type count,                                              (until
const Allocator& alloc =                                         C++20)
Allocator() );
constexpr basic_string(
const CharT* s, size_type                                        (since
count,                                                           C++20)
const Allocator& alloc =
Allocator() );
basic_string( const CharT*
s,                                                                      (until
const Allocator& alloc =                                                C++20)
Allocator() );
constexpr basic_string(
const CharT* s,                                                         (since
const Allocator& alloc =                                                C++20)
Allocator() );
template< class InputIt >

basic_string( InputIt first,                                                   (until
InputIt last,                                                                  C++20)
                             \fB(1)\fP
const Allocator& alloc =
Allocator() );
template< class InputIt >

constexpr basic_string(                                                        (since
InputIt first, InputIt last,                                                   C++20)

const Allocator& alloc =
Allocator() );
basic_string( const                                                                   (until
basic_string& other );           \fB(2)\fP                                                  C++20)
constexpr basic_string(                                                               (since
const basic_string& other );                                                          C++20)
basic_string( const                                                                          (since
basic_string& other,                 \fB(3)\fP                                                     C++11)
const Allocator& alloc );                                                                    (until
                                                                                             C++20)
constexpr basic_string(                                                                      (since
const basic_string& other,                                                                   C++20)
const Allocator& alloc );
                                                                                                    (since
basic_string( basic_string&&                \fB(3)\fP                                                     C++11)
other ) noexcept;                                                                                   (until
                                                                                                    C++20)
constexpr basic_string(                                                                             (since
basic_string&& other )                                                                              C++20)
noexcept;
basic_string( basic_string&&                                                                               (since
other,                                                                                                     C++11)
const Allocator& alloc );                          \fB(4)\fP                                                     (until
                                                                                                           C++20)
constexpr basic_string(                                                                                    (since
basic_string&& other,                                                                                      C++20)
const Allocator& alloc );                                 \fB(5)\fP
basic_string(                                                                                                     (since
std::initializer_list<CharT>                                                                                      C++11)
ilist,                                                                                                            (until
const Allocator& alloc =                                         \fB(6)\fP                                              C++20)
Allocator() );
constexpr basic_string(
std::initializer_list<CharT>                                                                                      (since
ilist,                                                                                                            C++20)
const Allocator& alloc =
Allocator() );
template< class                                                         \fB(7)\fP
StringViewLike >
                                                                               \fB(7)\fP                                       (since
explicit basic_string( const                                                                                             C++17)
StringViewLike& t,                                                                                                       (until
                                                                                                                         C++20)
const Allocator& alloc =                                                              \fB(8)\fP
Allocator() );
template< class
StringViewLike >                                                                             \fB(8)\fP

explicit constexpr                                                                                                       (since
basic_string( const                                                                                                      C++20)
StringViewLike& t,                                                                                  \fB(9)\fP

const Allocator& alloc =
Allocator() );
template< class
StringViewLike >                                                                                           \fB(10)\fP
                                                                                                                                (since
basic_string( const                                                                                                             C++17)
StringViewLike& t, size_type                                                                                                    (until
pos, size_type n,                                                                                                               C++20)

const Allocator& alloc =
Allocator() );
template< class                                                                                                   \fB(11)\fP
StringViewLike >

constexpr basic_string(                                                                                                         (since
const StringViewLike& t,                                                                                                        C++20)
size_type pos, size_type n,

const Allocator& alloc =
Allocator() );
basic_string( std::nullptr_t                                                                                             \fB(12)\fP   (since
) = delete;                                                                                                                     C++23)

   Constructs new string from a variety of data sources and optionally using user
   supplied allocator alloc.

   1) Default constructor. Constructs empty string (zero size and unspecified
   capacity). If no allocator is supplied, allocator is obtained from a
   default-constructed instance.
   2) Constructs the string with count copies of character ch.
   This constructor is not used for class template argument deduction if the Allocator
   type that would be deduced does not qualify as an allocator.
   \fI(since C++17)\fP
   3) Constructs the string with a substring [pos, pos+count) of other. If count ==
   npos, if count is not specified, or if the requested substring lasts past the end of
   the string, the resulting substring is [pos, other.size()).
   4) Constructs the string with the first count characters of character string pointed
   to by s. s can contain null characters. The length of the string is count. The
   behavior is undefined if [s, s + count) is not a valid range.
   5) Constructs the string with the contents initialized with a copy of the
   null-terminated character string pointed to by s. The length of the string is
   determined by the first null character. The behavior is undefined if [s, s +
   Traits::length(s)) is not a valid range (for example, if s is a null pointer).
   This constructor is not used for class template argument deduction if the Allocator
   type that would be deduced does not qualify as an allocator.
   \fI(since C++17)\fP
   6) Constructs the string with the contents of the range [first, last).

   If InputIt is an integral type, equivalent to overload \fB(2)\fP, as if by
   basic_string(static_cast<size_type>(first),                            \fI(until C++11)\fP
   static_cast<value_type>(last), alloc)
   This constructor only participates in overload resolution if InputIt   \fI(since C++11)\fP
   satisfies LegacyInputIterator.

   7) Copy constructor. Constructs the string with a copy of the contents of other.
   8) Move constructor. Constructs the string with the contents of other using move
   semantics. other is left in valid, but unspecified state.
   9) Constructs the string with the contents of the initializer list ilist.
   10) Implicitly converts t to a string view sv as if by std::basic_string_view<CharT,
   Traits> sv = t;, then initializes the string with the contents of sv, as if by
   basic_string(sv.data(), sv.size(), alloc). This overload participates in overload
   resolution only if std::is_convertible_v<const StringViewLike&,
   std::basic_string_view<CharT, Traits>> is true and std::is_convertible_v<const
   StringViewLike&, const CharT*> is false.
   11) Implicitly converts t to a string view sv as if by std::basic_string_view<CharT,
   Traits> sv = t;, then initializes the string with the subrange [pos, pos + n) of sv
   as if by basic_string(sv.substr(pos, n), alloc). This overload participates in
   overload resolution only if std::is_convertible_v<const StringViewLike&,
   std::basic_string_view<CharT, Traits>> is true .
   12) basic_string cannot be constructed from nullptr.

.SH Parameters

   alloc       - allocator to use for all memory allocations of this string
   count       - size of the resulting string
   ch          - value to initialize the string with
   pos         - position of the first character to include
   first, last - range to copy the characters from
   s           - pointer to an array of characters to use as source to initialize the
                 string with
   other       - another string to use as source to initialize the string with
   ilist       - std::initializer_list to initialize the string with
   t           - object (convertible to std::basic_string_view) to initialize the
                 string with

.SH Complexity

   1) constant
   2-4) linear in count
   5) linear in length of s
   6) linear in distance between first and last
   7) linear in size of other
   8) constant. If alloc is given and alloc != other.get_allocator(), then linear
   9) linear in size of ilist

.SH Exceptions

   3) std::out_of_range if pos > other.size()
   8) Throws nothing if alloc == str.get_allocator()
   11) std::out_of_range if pos is out of range

   Throws std::length_error if the length of the constructed string would exceed
   max_size() (for example, if count > max_size() for \fB(2)\fP). Calls to
   Allocator::allocate may throw.

.SH Notes

   Initialization with a string literal that contains embedded '\\0' characters uses the
   overload \fB(5)\fP, which stops at the first null character. This can be avoided by
   specifying a different constructor or by using operator""s:

 std::string s1 = "ab\\0\\0cd";   // s1 contains "ab"
 std::string s2{"ab\\0\\0cd", 6}; // s2 contains "ab\\0\\0cd"
 std::string s3 = "ab\\0\\0cd"s;  // s3 contains "ab\\0\\0cd"

.SH Example


// Run this code

 #include <iostream>
 #include <iomanip>
 #include <cassert>
 #include <iterator>
 #include <string>
 #include <cctype>

 int main()
 {
   {
     std::cout << "1) string(); ";
     std::string s;
     assert(s.empty() && (s.length() == 0) && (s.size() == 0));
     std::cout << "s.capacity(): " << s.capacity() << '\\n'; // unspecified
   }

   {
     std::cout << "2) string(size_type count, charT ch): ";
     std::string s(4, '=');
     std::cout << std::quoted(s) << '\\n'; // "===="
   }

   {
     std::cout << "3) string(const string& other, size_type pos, size_type count): ";
     std::string const other("Exemplary");
     std::string s(other, 0, other.length()-1);
     std::cout << quoted(s) << '\\n'; // "Exemplar"
   }

   {
     std::cout << "4) string(const string& other, size_type pos): ";
     std::string const other("Mutatis Mutandis");
     std::string s(other, 8);
     std::cout << quoted(s) << '\\n'; // "Mutandis", i.e. [8, 16)
   }

   {
     std::cout << "5) string(charT const* s, size_type count): ";
     std::string s("C-style string", 7);
     std::cout << quoted(s) << '\\n'; // "C-style", i.e. [0, 7)
   }

   {
     std::cout << "6) string(charT const* s): ";
     std::string s("C-style\\0string");
     std::cout << quoted(s) << '\\n'; // "C-style"
   }

   {
     std::cout << "7) string(InputIt first, InputIt last): ";
     char mutable_c_str[] = "another C-style string";
     std::string s(std::begin(mutable_c_str)+8, std::end(mutable_c_str)-1);
     std::cout << quoted(s) << '\\n'; // "C-style string"
   }

   {
     std::cout << "8) string(string&): ";
     std::string const other("Exemplar");
     std::string s(other);
     std::cout << quoted(s) << '\\n'; // "Exemplar"
   }

   {
     std::cout << "9) string(string&&): ";
     std::string s(std::string("C++ by ") + std::string("example"));
     std::cout << quoted(s) << '\\n'; // "C++ by example"
   }

   {
     std::cout << "α) string(std::initializer_list<charT>): ";
     std::string s({ 'C', '-', 's', 't', 'y', 'l', 'e' });
     std::cout << quoted(s) << '\\n'; // "C-style"
   }

   {
     // before C++11, overload resolution selects string(InputIt first, InputIt last)
     // [with InputIt = int] which behaves *as if* string(size_type count, charT ch)
     // after C++11 the InputIt constructor is disabled for integral types and calls:
     std::cout << "β) string(size_type count, charT ch) is called: ";
     std::string s(3, std::toupper('a'));
     std::cout << quoted(s) << '\\n'; // "AAA"
   }

   {
     [[maybe_unused]]
     auto zero = [] { /* ... */ return nullptr; };
 //  std::string s{ zero() }; // Before C++23: throws std::logic_error
                              // Since C++23: won't compile, see overload (12)
   }
 }

.SH Possible output:

 1) string(); s.capacity(): 15
 2) string(size_type count, charT ch): "===="
 3) string(const string& other, size_type pos, size_type count): "Exemplar"
 4) string(const string& other, size_type pos): "Mutandis"
 5) string(charT const* s, size_type count): "C-style"
 6) string(charT const* s): "C-style"
 7) string(InputIt first, InputIt last): "C-style string"
 8) string(string&): "Exemplar"
 9) string(string&&): "C++ by example"
 α) string(std::initializer_list<charT>): "C-style"
 β) string(size_type count, charT ch) is called: "AAA"

  Defect reports

   The following behavior-changing defect reports were applied retroactively to
   previously published C++ standards.

      DR    Applied to    Behavior as published              Correct behavior
                       there is no way to supply an there's a constructor for
   LWG 2583 C++98      allocator for                basic_string(str, pos, alloc)
                       basic_string(str, pos)
   LWG 2193 C++11      the default constructor is   made non-explicit
                       explicit
   LWG 2946 C++17      string_view overload causes  avoided by making it a template
                       ambiguity in some cases
                       two constructors may cause
   LWG 3076 C++17      ambiguities in class         constrained
                       template argument deduction

.SH See also

   assign        assign characters to a string
                 \fI(public member function)\fP
   operator=     assigns values to the string
                 \fI(public member function)\fP
   to_string     converts an integral or floating point value to string
   \fI(C++11)\fP       \fI(function)\fP
   to_wstring    converts an integral or floating point value to wstring
   \fI(C++11)\fP       \fI(function)\fP
   constructor   constructs a basic_string_view
   \fI(C++17)\fP       \fI(public member function of std::basic_string_view<CharT,Traits>)\fP
