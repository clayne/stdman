.TH std::swap 3 "2022.07.31" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::swap \- std::swap

.SH Synopsis
   Defined in header <algorithm>              \fI(until C++11)\fP
   Defined in header <utility>                \fI(since C++11)\fP
   Defined in header <string_view>            \fI(since C++17)\fP
   template< class T >                                      \fI(until C++11)\fP
   void swap( T& a, T& b );
   template< class T >                                      \fI(since C++11)\fP
   void swap( T& a, T& b ) noexcept(/*                      \fI(until C++20)\fP
   see below */);
   template< class T >
   constexpr void swap( T& a, T& b )      \fB(1)\fP               \fI(since C++20)\fP
   noexcept(/* see below */);
   template< class T2, std::size_t N >                                    \fI(since C++11)\fP
   void swap( T2 (&a)[N], T2 (&b)[N])                                     \fI(until C++20)\fP
   noexcept(/* see below */);                 \fB(2)\fP
   template< class T2, std::size_t N >
   constexpr void swap( T2 (&a)[N], T2                                    \fI(since C++20)\fP
   (&b)[N]) noexcept(/* see below */);

   Exchanges the given values.

   1) Swaps the values a and b.
   This overload does not participate in overload resolution unless
   std::is_move_constructible_v<T> && std::is_move_assignable_v<T> is true.
   \fI(since C++17)\fP
   2) Swaps the arrays a and b. In effect calls std::swap_ranges(a, a+N, b).
   This overload does not participate in overload resolution unless
   std::is_swappable_v<T2> is true.
   \fI(since C++17)\fP

.SH Parameters

   a, b              -              the values to be swapped
.SH Type requirements
   -
   T must meet the requirements of MoveAssignable and MoveConstructible.
   -
   T2 must meet the requirements of Swappable.

.SH Return value

   \fI(none)\fP

.SH Exceptions

   1)

   \fI(none)\fP                                          \fI(until C++11)\fP
   noexcept specification:
   noexcept(

   std::is_nothrow_move_constructible<T>::value && \fI(since C++11)\fP
   std::is_nothrow_move_assignable<T>::value

   )

   2)

   noexcept specification:
   noexcept(noexcept(swap(*a, *b)))
   The lookup for the identifier swap in the exception specification      \fI(since C++11)\fP
   finds this function template in addition to anything found by the      \fI(until C++17)\fP
   usual lookup rules, making the exception specification equivalent to
   C++17 std::is_nothrow_swappable.
   noexcept specification:                                                \fI(since C++17)\fP
   noexcept(std::is_nothrow_swappable_v<T2>)

.SH Complexity

   1) Constant
   2) Linear in N

.SH Specializations

   std::swap may be specialized in namespace std for program-defined
   types, but such specializations are not found by ADL (the namespace    \fI(until C++20)\fP
   std is not the associated namespace for the program-defined type).

   The expected way to make a program-defined type swappable is to provide a non-member
   function swap in the same namespace as the type: see Swappable for details.

   The following overloads are already provided by the standard library:

   std::swap(std::pair)                specializes the std::swap algorithm
   \fI(C++11)\fP                             \fI(function template)\fP
   std::swap(std::tuple)               specializes the std::swap algorithm
   \fI(C++11)\fP                             \fI(function template)\fP
   std::swap(std::shared_ptr)          specializes the std::swap algorithm
   \fI(C++11)\fP                             \fI(function template)\fP
   std::swap(std::weak_ptr)            specializes the std::swap algorithm
   \fI(C++11)\fP                             \fI(function template)\fP
   std::swap(std::unique_ptr)          specializes the std::swap algorithm
   \fI(C++11)\fP                             \fI(function template)\fP
   std::swap(std::function)            specializes the std::swap algorithm
   \fI(C++11)\fP                             \fI(function template)\fP
   std::swap(std::basic_string)        specializes the std::swap algorithm
                                       \fI(function template)\fP
   std::swap(std::array)               specializes the std::swap algorithm
   \fI(C++11)\fP                             \fI(function template)\fP
   std::swap(std::deque)               specializes the std::swap algorithm
                                       \fI(function template)\fP
   std::swap(std::forward_list)        specializes the std::swap algorithm
   \fI(C++11)\fP                             \fI(function template)\fP
   std::swap(std::list)                specializes the std::swap algorithm
                                       \fI(function template)\fP
   std::swap(std::vector)              specializes the std::swap algorithm
                                       \fI(function template)\fP
   std::swap(std::map)                 specializes the std::swap algorithm
                                       \fI(function template)\fP
   std::swap(std::multimap)            specializes the std::swap algorithm
                                       \fI(function template)\fP
   std::swap(std::set)                 specializes the std::swap algorithm
                                       \fI(function template)\fP
   std::swap(std::multiset)            specializes the std::swap algorithm
                                       \fI(function template)\fP
   std::swap(std::unordered_map)       specializes the std::swap algorithm
   \fI(C++11)\fP                             \fI(function template)\fP
   std::swap(std::unordered_multimap)  specializes the std::swap algorithm
   \fI(C++11)\fP                             \fI(function template)\fP
   std::swap(std::unordered_set)       specializes the std::swap algorithm
   \fI(C++11)\fP                             \fI(function template)\fP
   std::swap(std::unordered_multiset)  specializes the std::swap algorithm
   \fI(C++11)\fP                             \fI(function template)\fP
   std::swap(std::queue)               specializes the std::swap algorithm
   \fI(C++11)\fP                             \fI(function template)\fP
   std::swap(std::priority_queue)      specializes the std::swap algorithm
   \fI(C++11)\fP                             \fI(function template)\fP
   std::swap(std::stack)               specializes the std::swap algorithm
   \fI(C++11)\fP                             \fI(function template)\fP
   std::swap(std::valarray)            specializes the std::swap algorithm
   \fI(C++11)\fP                             \fI(function template)\fP
   std::swap(std::basic_stringbuf)     specializes the std::swap algorithm
   \fI(C++11)\fP                             \fI(function template)\fP
   std::swap(std::basic_istringstream) specializes the std::swap algorithm
   \fI(C++11)\fP                             \fI(function template)\fP
   std::swap(std::basic_ostringstream) specializes the std::swap algorithm
   \fI(C++11)\fP                             \fI(function template)\fP
   std::swap(std::basic_stringstream)  specializes the std::swap algorithm
   \fI(C++11)\fP                             \fI(function template)\fP
   std::swap(std::basic_filebuf)       specializes the std::swap algorithm
   \fI(C++11)\fP                             \fI(function template)\fP
   std::swap(std::basic_ifstream)      specializes the std::swap algorithm
   \fI(C++11)\fP                             \fI(function template)\fP
   std::swap(std::basic_ofstream)      specializes the std::swap algorithm
   \fI(C++11)\fP                             \fI(function template)\fP
   std::swap(std::basic_fstream)       specializes the std::swap algorithm
   \fI(C++11)\fP                             \fI(function template)\fP
   std::swap(std::basic_syncbuf)       specializes the std::swap algorithm
   (C++20)                             \fI(function template)\fP
   std::swap(std::basic_spanbuf)       specializes the std::swap algorithm
   (C++23)                             \fI(function template)\fP
   std::swap(std::basic_ispanstream)   specializes the std::swap algorithm
   (C++23)                             \fI(function template)\fP
   std::swap(std::basic_ospanstream)   specializes the std::swap algorithm
   (C++23)                             \fI(function template)\fP
   std::swap(std::basic_spanstream)    specializes the std::swap algorithm
   (C++23)                             \fI(function template)\fP
   std::swap(std::basic_regex)         specializes the std::swap algorithm
   \fI(C++11)\fP                             \fI(function template)\fP
   std::swap(std::match_results)       specializes the std::swap algorithm
   \fI(C++11)\fP                             \fI(function template)\fP
   std::swap(std::thread)              specializes the std::swap algorithm
   \fI(C++11)\fP                             \fI(function)\fP
   std::swap(std::unique_lock)         specialization of std::swap for unique_lock
   \fI(C++11)\fP                             \fI(function template)\fP
   std::swap(std::promise)             specializes the std::swap algorithm
   \fI(C++11)\fP                             \fI(function template)\fP
   std::swap(std::packaged_task)       specializes the std::swap algorithm
   \fI(C++11)\fP                             \fI(function template)\fP
   std::swap(std::optional)            specializes the std::swap algorithm
   \fI(C++17)\fP                             \fI(function template)\fP
   std::swap(std::any)                 specializes the std::swap algorithm
   \fI(C++17)\fP                             \fI(function)\fP
   std::swap(std::variant)             specializes the std::swap algorithm
   \fI(C++17)\fP                             \fI(function template)\fP
   swap(std::filesystem::path)         swaps two paths
   \fI(C++17)\fP                             \fI(function)\fP

.SH Example


// Run this code

 #include <algorithm>
 #include <iostream>

 namespace Ns {
 class A {
     int id{};

     friend void swap(A& lhs, A& rhs) {
         std::cout << "swap(" << lhs << ", " << rhs << ")\\n";
         std::swap(lhs.id, rhs.id);
     }

     friend std::ostream& operator<< (std::ostream& os, A const& a) {
         return os << "A::id=" << a.id;
     }

 public:
     A(int i) : id{i} { }
     A(A const&) = delete;
     A& operator = (A const&) = delete;
 };
 }

 int main()
 {
     int a = 5, b = 3;
     std::cout << a << ' ' << b << '\\n';
     std::swap(a,b);
     std::cout << a << ' ' << b << '\\n';

     Ns::A p{6}, q{9};
     std::cout << p << ' ' << q << '\\n';
 //  std::swap(p, q);  // error, type requirements are not satisfied
     swap(p, q);  // OK, ADL finds the appropriate friend `swap`
     std::cout << p << ' ' << q << '\\n';
 }

.SH Output:

 5 3
 3 5
 A::id=6 A::id=9
 swap(A::id=6, A::id=9)
 A::id=9 A::id=6

  Defect reports

   The following behavior-changing defect reports were applied retroactively to
   previously published C++ standards.

      DR    Applied to              Behavior as published              Correct behavior
   LWG 2554 C++11      swapping multi-dimensional arrays can never be  made to work
                       noexcept due to name lookup problems

.SH See also

   ranges::swap swaps the values of two objects
   (C++20)      (customization point object)
   iter_swap    swaps the elements pointed to by two iterators
                \fI(function template)\fP
   swap_ranges  swaps two ranges of elements
                \fI(function template)\fP
   exchange     replaces the argument with a new value and returns its previous value
   \fI(C++14)\fP      \fI(function template)\fP
