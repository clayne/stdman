.TH std::cbrt,std::cbrtf,std::cbrtl 3 "2022.07.31" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::cbrt,std::cbrtf,std::cbrtl \- std::cbrt,std::cbrtf,std::cbrtl

.SH Synopsis
   Defined in header <cmath>
   float cbrt ( float arg );             \fB(1)\fP \fI(since C++11)\fP
   float cbrtf( float arg );
   double cbrt ( double arg );           \fB(2)\fP \fI(since C++11)\fP
   long double cbrt ( long double arg ); \fB(3)\fP \fI(since C++11)\fP
   long double cbrtl( long double arg );
   double cbrt ( IntegralType arg );     \fB(4)\fP \fI(since C++11)\fP

   1-3) Computes the cube root of arg.
   4) A set of overloads or a function template accepting an argument of any integral
   type. Equivalent to 2) (the argument is cast to double).

.SH Parameters

   arg - value of a floating-point or Integral type

.SH Return value

   If no errors occur, the cube root of arg (\\(\\small{\\sqrt[3]{arg} }\\)
   3
   √
   arg), is returned.

   If a range error occurs due to underflow, the correct result (after rounding) is
   returned.

.SH Error handling

   Errors are reported as specified in math_errhandling

   If the implementation supports IEEE floating-point arithmetic (IEC 60559),

     * if the argument is ±0 or ±∞, it is returned, unchanged
     * if the argument is NaN, NaN is returned.

.SH Notes

   std::cbrt(arg) is not equivalent to std::pow(arg, 1.0/3) because the rational number
   \\(\\small{\\frac1{3} }\\)

   1
   3

   is typically not equal to 1.0/3 and std::pow cannot raise a negative base to a
   fractional exponent. Moreover, std::cbrt(arg) usually gives more accurate results
   than std::pow(arg, 1.0/3) (see example).

.SH Example


// Run this code

 #include <iostream>
 #include <iomanip>
 #include <cmath>
 #include <limits>

 int main()
 {
     std::cout
         << "Normal use:\\n"
         << "cbrt(729)       = " << std::cbrt(729) << '\\n'
         << "cbrt(-0.125)    = " << std::cbrt(-0.125) << '\\n'
         << "Special values:\\n"
         << "cbrt(-0)        = " << std::cbrt(-0.0) << '\\n'
         << "cbrt(+inf)      = " << std::cbrt(INFINITY) << '\\n'
         << "Accuracy and comparison with `pow`:\\n"
         << std::setprecision(std::numeric_limits<double>::max_digits10)
         << "cbrt(343)       = " << std::cbrt(343) << '\\n'
         << "pow(343,1.0/3)  = " << std::pow(343, 1.0/3) << '\\n'
         << "cbrt(-343)      = " << std::cbrt(-343) << '\\n'
         << "pow(-343,1.0/3) = " << std::pow(-343, 1.0/3) << '\\n';
 }

.SH Possible output:

 Normal use:
 cbrt(729)       = 9
 cbrt(-0.125)    = -0.5
 Special values:
 cbrt(-0)        = -0
 cbrt(+inf)      = inf
 Accuracy and comparison with `pow`:
 cbrt(343)       = 7
 pow(343,1.0/3)  = 6.9999999999999991
 cbrt(-343)      = -7
 pow(-343,1.0/3) = -nan

.SH See also

   pow
   powf    raises a number to the given power (\\(\\small{x^y}\\)x^y)
   powl    \fI(function)\fP
   \fI(C++11)\fP
   \fI(C++11)\fP
   sqrt    computes square root (\\(\\small{\\sqrt{x} }\\)
   sqrtf   √
   sqrtl   x)
   \fI(C++11)\fP \fI(function)\fP
   \fI(C++11)\fP
           computes square root of the sum of the squares of two or three \fI(C++17)\fP given
           numbers (\\(\\scriptsize{\\sqrt{x^2+y^2} }\\)
           √
   hypot   x2
   hypotf  +y2
   hypotl  ), (\\(\\scriptsize{\\sqrt{x^2+y^2+z^2} }\\)
   \fI(C++11)\fP √
   \fI(C++11)\fP x2
   \fI(C++11)\fP +y2
           +z2
           )
           \fI(function)\fP
