.TH std::trunc,std::truncf,std::truncl 3 "2022.07.31" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::trunc,std::truncf,std::truncl \- std::trunc,std::truncf,std::truncl

.SH Synopsis
   Defined in header <cmath>
   float trunc ( float arg );             \fB(1)\fP \fI(since C++11)\fP
                                              (constexpr since C++23)
   float truncf( float arg );             \fB(2)\fP \fI(since C++11)\fP
                                              (constexpr since C++23)
   double trunc ( double arg );           \fB(3)\fP \fI(since C++11)\fP
                                              (constexpr since C++23)
   long double trunc ( long double arg ); \fB(4)\fP \fI(since C++11)\fP
                                              (constexpr since C++23)
   long double truncl( long double arg ); \fB(5)\fP \fI(since C++11)\fP
                                              (constexpr since C++23)
   double trunc ( IntegralType arg );     \fB(6)\fP \fI(since C++11)\fP
                                              (constexpr since C++23)

   1-5) Computes the nearest integer not greater in magnitude than arg.
   6) A set of overloads or a function template accepting an argument of any integral
   type. Equivalent to \fB(3)\fP (the argument is cast to double).

.SH Parameters

   arg - floating point value

.SH Return value

   If no errors occur, the nearest integer value not greater in magnitude than arg (in
   other words, arg rounded towards zero) is returned.

.SH Return value
   math-trunc.svg
   Argument

.SH Error handling

   Errors are reported as specified in math_errhandling.

   If the implementation supports IEEE floating-point arithmetic (IEC 60559),

     * The current rounding mode has no effect.
     * If arg is ±∞, it is returned, unmodified
     * If arg is ±0, it is returned, unmodified
     * If arg is NaN, NaN is returned

.SH Notes

   FE_INEXACT may be (but isn't required to be) raised when truncating a non-integer
   finite value.

   The largest representable floating-point values are exact integers in all standard
   floating-point formats, so this function never overflows on its own; however the
   result may overflow any integer type (including std::intmax_t), when stored in an
   integer variable.

   The implicit conversion from floating-point to integral types also rounds towards
   zero, but is limited to the values that can be represented by the target type.

.SH Example


// Run this code

 #include <cmath>
 #include <iostream>
 #include <initializer_list>

 int main()
 {
     const auto data = std::initializer_list<double>{
         +2.7, -2.9, +0.7, -0.9, +0.0, 0.0, -INFINITY, +INFINITY, -NAN, +NAN
     };

     std::cout << std::showpos;
     for (double const x : data) {
         std::cout << "trunc(" << x << ") == " << std::trunc(x) << '\\n';
     }
 }

.SH Possible output:

 trunc(+2.7) == +2
 trunc(-2.9) == -2
 trunc(+0.7) == +0
 trunc(-0.9) == -0
 trunc(+0) == +0
 trunc(+0) == +0
 trunc(-inf) == -inf
 trunc(+inf) == +inf
 trunc(-nan) == -nan
 trunc(+nan) == +nan

.SH See also

   floor
   floorf   nearest integer not greater than the given value
   floorl   \fI(function)\fP
   \fI(C++11)\fP
   \fI(C++11)\fP
   ceil
   ceilf    nearest integer not less than the given value
   ceill    \fI(function)\fP
   \fI(C++11)\fP
   \fI(C++11)\fP
   round
   roundf
   roundl
   lround
   lroundf
   lroundl
   llround
   llroundf
   llroundl nearest integer, rounding away from zero in halfway cases
   \fI(C++11)\fP  \fI(function)\fP
   \fI(C++11)\fP
   \fI(C++11)\fP
   \fI(C++11)\fP
   \fI(C++11)\fP
   \fI(C++11)\fP
   \fI(C++11)\fP
   \fI(C++11)\fP
   \fI(C++11)\fP
