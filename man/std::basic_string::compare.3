.TH std::basic_string::compare 3 "2022.07.31" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::basic_string::compare \- std::basic_string::compare

.SH Synopsis
   int compare(
   const                   (until
   basic_string&           C++11)
   str ) const;
   int compare(            (since
   const                   C++11)
   basic_string&           (until
   str ) const             C++20)
   noexcept;
   constexpr int
   compare( const          (since
   basic_string&           C++20)
   str ) const
   noexcept;
   int compare(
   size_type pos1,
   size_type                      (until
   count1,                        C++20)
   const
   basic_string&
   str ) const;
   constexpr int
   compare(
   size_type pos1,
   size_type                      (since
   count1,                        C++20)
   const
   basic_string&
   str ) const;
   int compare(
   size_type pos1,
   size_type
   count1,

   const                                 (until
   basic_string&                         C++14)
   str,

   size_type pos2,
   size_type
   count2 ) const;
   int compare(
   size_type pos1,
   size_type
   count1,
                                         (since
   const                                 C++14)
   basic_string&                         (until
   str,                                  C++20)

   size_type pos2,
   size_type
   count2 = npos )
   const;
   constexpr int
   compare(
   size_type pos1,
   size_type
   count1,

   const                                 (since
   basic_string&                         C++20)
   str,

   size_type pos2,
   size_type
   count2 = npos )
   const;
   int compare(                                 (until
   const CharT* s                               C++20)
   ) const;
   constexpr int
   compare( const                               (since
   CharT* s )                                   C++20)
   const;
   int compare(
   size_type pos1,
   size_type                                           (until
   count1,                                             C++20)
   const CharT* s
   ) const;
   constexpr int
   compare(
   size_type pos1,                                     (since
   size_type                                           C++20)
   count1,
   const CharT* s
   ) const;
   int compare(
   size_type pos1,
   size_type                                                  (until
   count1,                                                    C++20)
   const CharT* s, \fB(1)\fP
   size_type
   count2 ) const;
   constexpr int
   compare(
   size_type pos1,
   size_type                                                  (since
   count1,             \fB(2)\fP                                    C++20)
   const CharT* s,
   size_type
   count2 ) const;
   template <
   class
   StringViewLike
   >                       \fB(3)\fP                                       (since
   int compare(                                                      C++17)
   const                                                             (until
   StringViewLike&                                                   C++20)
   t ) const
   noexcept(/* see
   below */);
   template <
   class
   StringViewLike
   >
   constexpr int                                                     (since
   compare( const                                                    C++20)
   StringViewLike&
   t ) const
   noexcept(/* see
   below */);
   template <
   class
   StringViewLike
   >                              \fB(4)\fP
                                                                            (since
   int compare(                                                             C++17)
   size_type pos1,                       \fB(5)\fP                                (until
   size_type                                                                C++20)
   count1,

   const
   StringViewLike&
   t ) const;
   template <                                   \fB(6)\fP
   class
   StringViewLike
   >

   constexpr int
   compare(                                                                 (since
   size_type pos1,                                     \fB(7)\fP                  C++20)
   size_type
   count1,

   const
   StringViewLike&
   t ) const;
   template <
   class
   StringViewLike
   >                                                          \fB(8)\fP

   int compare(
   size_type pos1,                                                                 (since
   size_type                                                                       C++17)
   count1,                                                                         (until
   const                                                                           C++20)
   StringViewLike&
   t,

   size_type pos2,
   size_type
   count2 = npos)
   const;
   template <                                                        \fB(9)\fP
   class
   StringViewLike
   >

   constexpr int
   compare(
   size_type pos1,
   size_type                                                                       (since
   count1,                                                                         C++20)
   const
   StringViewLike&
   t,

   size_type pos2,
   size_type
   count2 = npos)
   const;

   Compares two character sequences.

   1) Compares this string to str.
   2) Compares a [pos1, pos1+count1) substring of this string to str. If count1 >
   size() - pos1 the substring is [pos1, size()).
   3) Compares a [pos1, pos1+count1) substring of this string to a substring [pos2,
   pos2+count2) of str. If count1 > size() - pos1 the first substring is [pos1,
   size()). Likewise, count2 > str.size() - pos2 the second substring is [pos2,
   str.size()).
   4) Compares this string to the null-terminated character sequence beginning at the
   character pointed to by s with length Traits::length(s).
   5) Compares a [pos1, pos1+count1) substring of this string to the null-terminated
   character sequence beginning at the character pointed to by s with length
   Traits::length(s). If count1 > size() - pos1 the substring is [pos1, size()).
   6) Compares a [pos1, pos1+count1) substring of this string to the characters in the
   range [s, s + count2). If count1 > size() - pos1 the substring is [pos1, size()).
   (Note: the characters in the range [s, s + count2) may include null characters.)
   7) Implicitly converts t to a string view sv as if by std::basic_string_view<CharT,
   Traits> sv = t;, then compares this string to sv. This overload participates in
   overload resolution only if std::is_convertible_v<const StringViewLike&,
   std::basic_string_view<CharT, Traits>> is true and std::is_convertible_v<const
   StringViewLike&, const CharT*> is false.
   8) Implicitly converts t to a string view sv as if by std::basic_string_view<CharT,
   Traits> sv = t;, then compares a [pos1, pos1+count1) substring of this string to sv,
   as if by std::basic_string_view<CharT, Traits>(*this).substr(pos1,
   count1).compare(sv). This overload participates in overload resolution only if
   std::is_convertible_v<const StringViewLike&, std::basic_string_view<CharT, Traits>>
   is true and std::is_convertible_v<const StringViewLike&, const CharT*> is false.
   9) Implicitly converts t to a string view sv as if by std::basic_string_view<CharT,
   Traits> sv = t;, then compares a [pos1, pos1+count1) substring of this string to a
   substring [pos2, pos2+count2) of sv as if by std::basic_string_view<CharT,
   Traits>(*this).substr(pos1, count1).compare(sv.substr(pos2, count2)). This overload
   participates in overload resolution only if std::is_convertible_v<const
   StringViewLike&, std::basic_string_view<CharT, Traits>> is true and
   std::is_convertible_v<const StringViewLike&, const CharT*> is false.

   A character sequence consisting of count1 characters starting at data1 is compared
   to a character sequence consisting of count2 characters starting at data2 as
   follows. First, calculate the number of characters to compare, as if by size_type
   rlen = std::min(count1, count2). Then compare the sequences by calling
   Traits::compare(data1, data2, rlen). For standard strings this function performs
   character-by-character lexicographical comparison. If the result is zero (the
   character sequences are equal so far), then their sizes are compared as follows:

                        Condition                             Result       Return value
   Traits::compare(data1, data2, rlen) < 0              data1 is less than <0
                                                        data2
                                          size1 < size2 data1 is less than <0
                                                        data2
   Traits::compare(data1, data2, rlen) == size1 ==      data1 is equal to  0
   0                                      size2         data2
                                          size1 > size2 data1 is greater   >0
                                                        than data2
   Traits::compare(data1, data2, rlen) > 0              data1 is greater   >0
                                                        than data2

.SH Parameters

   str    - other string to compare to
   s      - pointer to the character string to compare to
   count1 - number of characters of this string to compare
   pos1   - position of the first character in this string to compare
   count2 - number of characters of the given string to compare
   pos2   - position of the first character of the given string to compare
   t      - object (convertible to std::basic_string_view) to compare to

.SH Return value

   negative value if *this appears before the character sequence specified by the
   arguments, in lexicographical order

   zero if both character sequences compare equivalent

   positive value if *this appears after the character sequence specified by the
   arguments, in lexicographical order

.SH Exceptions

   The overloads taking parameters named pos1 or pos2 throws std::out_of_range if the
   argument is out of range.

   7)
   noexcept specification:
   noexcept(std::is_nothrow_convertible_v<const T&, std::basic_string_view<CharT,
   Traits>>)
   8-9) Throws anything thrown by the conversion to basic_string_view.

.SH Possible implementation

template<class CharT, class Traits, class Alloc>
int basic_string<CharT, Traits, Alloc>::compare(const std::basic_string& s) const noexcept
{
    size_type lhs_sz = size();
    size_type rhs_sz = s.size();
    int result = traits_type::compare(data(), s.data(), std::min(lhs_sz, rhs_sz));
    if (result != 0)
        return result;
    if (lhs_sz < rhs_sz)
        return -1;
    if (lhs_sz > rhs_sz)
        return 1;
    return 0;
}

.SH Notes

   For the situations when three-way comparison is not required, std::basic_string
   provides the usual relational operators (<, <=, ==, >, etc).

   By default (with the default std::char_traits), this function is not
   locale-sensitive. See std::collate::compare for locale-aware three-way string
   comparison.

.SH Example


// Run this code

 #include <cassert>
 #include <string>
 #include <iostream>

 int main()
 {
     // 1) Compare with other string
     {
         int compare_value{
             std::string{"Batman"}.compare(std::string{"Superman"})
         };
         std::cout << (
             compare_value < 0 ? "Batman comes before Superman\\n" :
             compare_value > 0 ? "Superman comes before Batman\\n" :
             "Superman and Batman are the same.\\n"
         );
     }

     // 2) Compare substring with other string
     {
         int compare_value{
             std::string{"Batman"}.compare(3, 3, std::string{"Superman"})
         };
         std::cout << (
             compare_value < 0 ? "man comes before Superman\\n" :
             compare_value > 0 ? "Superman comes before man\\n" :
             "man and Superman are the same.\\n"
         );
     }

     // 3) Compare substring with other substring
     {
         std::string a{"Batman"};
         std::string b{"Superman"};

         int compare_value{a.compare(3, 3, b, 5, 3)};

         std::cout << (
             compare_value < 0 ? "man comes before man\\n" :
             compare_value > 0 ? "man comes before man\\n" :
             "man and man are the same.\\n"
         );
         // Compare substring with other substring
         // defaulting to end of other string
         assert(compare_value == a.compare(3, 3, b, 5));
     }

     // 4) Compare with char pointer
     {
         int compare_value{std::string{"Batman"}.compare("Superman")};

         std::cout << (
             compare_value < 0 ? "Batman comes before Superman\\n" :
             compare_value > 0 ? "Superman comes before Batman\\n" :
             "Superman and Batman are the same.\\n"
         );
     }

     // 5) Compare substring with char pointer
     {
         int compare_value{std::string{"Batman"}.compare(3, 3, "Superman")};

         std::cout << (
             compare_value < 0 ? "man comes before Superman\\n" :
             compare_value > 0 ? "Superman comes before man\\n" :
             "man and Superman are the same.\\n"
         );
     }

     // 6) Compare substring with char pointer substring
     {
         int compare_value{std::string{"Batman"}.compare(0, 3, "Superman", 5)};

         std::cout << (
             compare_value < 0 ? "Bat comes before Super\\n" :
             compare_value > 0 ? "Super comes before Bat\\n" :
             "Super and Bat are the same.\\n"
         );
     }
 }

.SH Output:

 Batman comes before Superman
 Superman comes before man
 man and man are the same.
 Batman comes before Superman
 Superman comes before man
 Bat comes before Super

  Defect reports

   The following behavior-changing defect reports were applied retroactively to
   previously published C++ standards.

      DR    Applied to           Behavior as published              Correct behavior
   LWG 2946 C++17      string_view overload causes ambiguity in  avoided by making it a
                       some cases                                template
   P1148R0  C++17      noexcept for overload \fB(7)\fP was accidently  restored
                       dropped by LWG2946

.SH See also

   operator==
   operator!=
   operator<
   operator>
   operator<=
   operator>=              lexicographically compares two strings
   operator<=>             \fI(function template)\fP
   (removed in C++20)
   (removed in C++20)
   (removed in C++20)
   (removed in C++20)
   (removed in C++20)
   (C++20)
   substr                  returns a substring
                           \fI(public member function)\fP
   collate                 defines lexicographical comparison and hashing of strings
                           \fI(class template)\fP
   strcoll                 compares two strings in accordance to the current locale
                           \fI(function)\fP
                           returns true if one range is lexicographically less than
   lexicographical_compare another
                           \fI(function template)\fP
   compare                 compares two views
   \fI(C++17)\fP                 \fI\fI(public member\fP function of\fP
                           std::basic_string_view<CharT,Traits>)
