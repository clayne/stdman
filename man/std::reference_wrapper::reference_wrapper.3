.TH std::reference_wrapper::reference_wrapper 3 "2022.07.31" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::reference_wrapper::reference_wrapper \- std::reference_wrapper::reference_wrapper

.SH Synopsis
   template< class U >
   reference_wrapper( U&& x ) noexcept(/*see                \fI(until C++20)\fP
   below*/) ;
   template< class U >
   constexpr reference_wrapper( U&& x )             \fB(1)\fP     \fI(since C++20)\fP
   noexcept(/*see below*/) ;
   reference_wrapper( const reference_wrapper&                            \fI(until C++20)\fP
   other ) noexcept;                                    \fB(2)\fP
   constexpr reference_wrapper( const                                     \fI(since C++20)\fP
   reference_wrapper& other ) noexcept;

   Constructs a new reference wrapper.

   1) Converts x to T& as if by T& t = std::forward<U>(x);, then stores a reference to
   t. This overload participates in overload resolution only if typename
   std::decay<U>::type is not the same type as reference_wrapper and the expression
   FUN(std::declval<U>()) is well-formed, where FUN names the set of imaginary
   functions

 void FUN(T&) noexcept;
 void FUN(T&&) = delete;

   2) Copy constructor. Stores a reference to other.get().

.SH Parameters

   x     - an object to wrap
   other - another reference wrapper

.SH Exceptions

   1)
   noexcept specification:
   noexcept(noexcept(FUN(std::declval<U>())))
   where FUN is the set of imaginary functions described in the description above.

.SH Example

    This section is incomplete
    Reason: no example

  Defect reports

   The following behavior-changing defect reports were applied retroactively to
   previously published C++ standards.

      DR    Applied to           Behavior as published              Correct behavior
                       deleted reference_wrapper(T&&) constructor replaced with a
   LWG 2993 C++11      interferes                                 constructor template
                       with overload resolution in some cases
