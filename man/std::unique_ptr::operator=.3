.TH std::unique_ptr::operator= 3 "2022.07.31" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::unique_ptr::operator= \- std::unique_ptr::operator=

.SH Synopsis
   members of the primary template, unique_ptr<T>
   unique_ptr& operator=( unique_ptr&& r ) noexcept;        \fB(1)\fP (constexpr since C++23)
   template< class U, class E >                             \fB(2)\fP (constexpr since C++23)
   unique_ptr& operator=( unique_ptr<U,E>&& r ) noexcept;
   unique_ptr& operator=( std::nullptr_t ) noexcept;        \fB(3)\fP (constexpr since C++23)
   members of the specialization for arrays,
   unique_ptr<T[]>
   unique_ptr& operator=( unique_ptr&& r ) noexcept;        \fB(1)\fP (constexpr since C++23)
   template< class U, class E >                             \fB(2)\fP (constexpr since C++23)
   unique_ptr& operator=( unique_ptr<U,E>&& r ) noexcept;
   unique_ptr& operator=( std::nullptr_t ) noexcept;        \fB(3)\fP (constexpr since C++23)

   1) Move assignment operator. Transfers ownership from r to *this as if by calling
   reset(r.release()) followed by an assignment of get_deleter() from
   std::forward<Deleter>(r.get_deleter()).

   If Deleter is not a reference type, requires that it is nothrow-MoveAssignable.
   If Deleter is a reference type, requires that std::remove_reference<Deleter>::type
   is nothrow-CopyAssignable.

   The move assignment operator only participates in overload resolution if
   std::is_move_assignable<Deleter>::value is true.
   2) Converting assignment operator. Behaves same as \fB(1)\fP, except that

     * This assignment operator of the primary template only participates in overload
       resolution if U is not an array type and unique_ptr<U,E>::pointer is implicitly
       convertible to pointer and std::is_assignable<Deleter&, E&&>::value is true.
     * This assignment operator in the specialization for arrays, std::unique_ptr<T[]>
       behaves the same as in the primary template, except that will only participate
       in overload resolution if all of the following is true:

              * U is an array type
              * pointer is the same type as element_type*
              * unique_ptr<U,E>::pointer is the same type as
                unique_ptr<U,E>::element_type*
              * unique_ptr<U,E>::element_type(*)[] is convertible to element_type(*)[]
              * std::is_assignable<Deleter&, E&&>::value is true

   3) Effectively the same as calling reset().

   Note that unique_ptr's assignment operator only accepts rvalues, which are typically
   generated by std::move. (The unique_ptr class explicitly deletes its lvalue copy
   constructor and lvalue assignment operator.)

.SH Parameters

   r - smart pointer from which ownership will be transferred

.SH Return value

   *this

.SH Example


// Run this code

 #include <iostream>
 #include <memory>

 struct Foo {
     int id;
     Foo(int id) : id(id) { std::cout << "Foo " << id << '\\n'; }
     ~Foo() { std::cout << "~Foo " << id << '\\n'; }
 };

 int main()
 {
     std::unique_ptr<Foo> p1( std::make_unique<Foo>(1) );

     {
         std::cout << "Creating new Foo...\\n";
         std::unique_ptr<Foo> p2( std::make_unique<Foo>(2) );
         // p1 = p2; // Error ! can't copy unique_ptr
         p1 = std::move(p2);
         std::cout << "About to leave inner block...\\n";

         // Foo instance will continue to live,
         // despite p2 going out of scope
     }

     std::cout << "About to leave program...\\n";
 }

.SH Output:

 Foo 1
 Creating new Foo...
 Foo 2
 ~Foo 1
 About to leave inner block...
 About to leave program...
 ~Foo 2

  Defect reports

   The following behavior-changing defect reports were applied retroactively to
   previously published C++ standards.

      DR    Applied to              Behavior as published              Correct behavior
   LWG 2118 C++11      unique_ptr<T[]>::operator= rejected             accepts
                       qualification conversions
   LWG 2228 C++11      the converting assignment operator was not      constrained
                       constrained
   LWG 2899 C++11      the move assignment operator was not            constrained
                       constrained
