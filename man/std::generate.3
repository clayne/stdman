.TH std::generate 3 "2022.07.31" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::generate \- std::generate

.SH Synopsis
   Defined in header <algorithm>
   template< class ForwardIt, class Generator >                           \fI(until C++20)\fP
   void generate( ForwardIt first, ForwardIt last, Generator g );
   template< class ForwardIt, class Generator >
   constexpr void generate( ForwardIt first, ForwardIt last,              \fI(since C++20)\fP
   Generator g );                                                 \fB(1)\fP
   template< class ExecutionPolicy, class ForwardIt, class
   Generator >                                                        \fB(2)\fP \fI(since C++17)\fP
   void generate( ExecutionPolicy&& policy, ForwardIt first,
   ForwardIt last, Generator g );

   1) Assigns each element in range [first, last) a value generated by the given
   function object g.
   2) Same as \fB(1)\fP, but executed according to policy. This overload does not participate
   in overload resolution unless
   std::is_execution_policy_v<std::decay_t<ExecutionPolicy>>
   \fI(until C++20)\fP
   std::is_execution_policy_v<std::remove_cvref_t<ExecutionPolicy>>
   \fI(since C++20)\fP is true.

.SH Parameters

   first, last - the range of elements to generate
   policy      - the execution policy to use. See execution policy for details.
                 generator function object that will be called.

                 The signature of the function should be equivalent to the following:
   g           -
                 Ret fun();

                 The type Ret must be such that an object of type ForwardIt can be
                 dereferenced and assigned a value of type Ret.
.SH Type requirements
   -
   ForwardIt must meet the requirements of LegacyForwardIterator.

.SH Return value

   \fI(none)\fP

.SH Complexity

   Exactly std::distance(first, last) invocations of g() and assignments.

.SH Exceptions

   The overload with a template parameter named ExecutionPolicy reports errors as
   follows:

     * If execution of a function invoked as part of the algorithm throws an exception
       and ExecutionPolicy is one of the standard policies, std::terminate is called.
       For any other ExecutionPolicy, the behavior is implementation-defined.
     * If the algorithm fails to allocate memory, std::bad_alloc is thrown.

.SH Possible implementation

   template<class ForwardIt, class Generator>
   constexpr // Since C++20
   void generate(ForwardIt first, ForwardIt last, Generator g)
   {
       while (first != last) {
           *first++ = g();
       }
   }

.SH Example


// Run this code

 #include <algorithm>
 #include <iostream>
 #include <vector>

 int f()
 {
     static int i;
     return ++i;
 }

 int main()
 {
     std::vector<int> v(5);
     auto print = [&] {
         for (std::cout << "v: "; auto iv: v)
             std::cout << iv << " ";
         std::cout << "\\n";
     };

     std::generate(v.begin(), v.end(), f);
     print();

     // Initialize with default values 0,1,2,3,4 from a lambda function
     // Equivalent to std::iota(v.begin(), v.end(), 0);
     std::generate(v.begin(), v.end(), [n = 0] () mutable { return n++; });
     print();
 }

.SH Output:

 v: 1 2 3 4 5
 v: 0 1 2 3 4

.SH See also

   fill             copy-assigns the given value to every element in a range
                    \fI(function template)\fP
                    assigns the results of successive function calls to N elements in a
   generate_n       range
                    \fI(function template)\fP
   iota             fills a range with successive increments of the starting value
   \fI(C++11)\fP          \fI(function template)\fP
   ranges::generate saves the result of a function in a range
   (C++20)          (niebloid)
