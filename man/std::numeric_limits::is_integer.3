.TH std::numeric_limits::is_integer 3 "2022.07.31" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::numeric_limits::is_integer \- std::numeric_limits::is_integer

.SH Synopsis
   static const bool is_integer;      \fI(until C++11)\fP
   static constexpr bool is_integer;  \fI(since C++11)\fP

   The value of std::numeric_limits<T>::is_integer is true for all integer arithmetic
   types T and false otherwise. This constant is meaningful for all specializations.

.SH Standard specializations

   T                          value of std::numeric_limits<T>::is_integer
   /* non-specialized */      false
   bool                       true
   char                       true
   signed char                true
   unsigned char              true
   wchar_t                    true
   char8_t (C++20)            true
   char16_t \fI(C++11)\fP           true
   char32_t \fI(C++11)\fP           true
   short                      true
   unsigned short             true
   int                        true
   unsigned int               true
   long                       true
   unsigned long              true
   long long \fI(C++11)\fP          true
   unsigned long long \fI(C++11)\fP true
   float                      false
   double                     false
   long double                false

.SH Example


// Run this code

 #include <cstddef>
 #include <cstdint>
 #include <numeric>

 int main()
 {
     static_assert(
             std::numeric_limits<bool>::is_integer
         &&  std::numeric_limits<std::size_t>::is_integer
         &&  std::numeric_limits<std::int32_t>::is_integer
         &&  std::numeric_limits<std::int64_t>::is_integer
         &&  std::numeric_limits<decltype(42)>::is_integer
         && !std::numeric_limits<float>::is_integer
         && !std::numeric_limits<double>::is_integer
         && !std::numeric_limits<long double>::is_integer
         && !std::numeric_limits<decltype([](){})>::is_integer // P0315R4
     );
 }

.SH See also

   is_integral checks if a type is an integral type
   \fI(C++11)\fP     \fI(class template)\fP
   is_signed   identifies signed types
   \fB[static]\fP    \fI(public static member constant)\fP
   is_exact    identifies exact types
   \fB[static]\fP    \fI(public static member constant)\fP
   is_bounded  identifies types that represent a finite set of values
   \fB[static]\fP    \fI(public static member constant)\fP
